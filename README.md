# Introduction

To build projects written on C and C++, various build system are used. The most famous build systems are CMake, GNU Make, Scons, Shake, and the system used to build the Boost libraries. Consider each of these build system.  

System GNU Make takes a Makefile describing the build script of the project. Writing this script manually is not very convenient, if there are a lot of source files. The advantage of this system is that this system works 
both under Linux, and under Windows.

Systems SCons and CMake are wrappers over Make utility and generate input files for Make. System SCons is written in language Python 2.7, and has installing problem under Windows 7. There are no installing problems under Linux.
The inability to work under Windows is disadvantage of this system. The Makefile generated by CMake system, are complicated and contains absolute paths to source files and to compiler. By default, CMake uses C++ compiler,
which is standard for an operating system. Standard C++ compiler for Linux is g++ (a compiler from GCC collection). Standard C++ compiler for Windows is a compiler from Microsoft Visual Studio. However, Visual Studio compiler
does not fully support recent standards of C++ language, unlike the compiler of the GCC collection. Hence, it is better to use g++ under Windows. But, under Windows, in order for CMake used g++ and the needed keys of g++, you need to write a 
long chain of command-line arguments. As for Linux, then, in addition to the compiler from collection GCC can be installed, for example, compilers of a set of Clang. Under Linux, in order for CMake used clang, you need to write a 
long chain of command-line arguments. The build system for the Boost libraries is not recommended by an author of one of Boost library, because it is difficult to use this build system.  

The build system Shake is written in Haskell, and requires installed system Haskell Stack. But Haskell Stack does not work under Linux. The purpose of the system Haskell Stack is to write Makefiles as programs in Haskell, then to compile 
them by Haskell compiler, and to run resulting program. Resulting program will build the needed project. To use in C++ projects, is is disadvatage. Therefore, we need a more simple build system. It is the goal of the project Murlyka.  

# Input file format

Input file consists of an arbitrary sequence the following commands (this sequence can be empty):

- _project_(project\_name main\_file)

- _compiler_(compiler\_name)

- _compiler\_flags_(compiler\_flags)

- _linker_(linker\_name)

- _linker\_flags_(linker\_flags)

- _source\_dir_(directory\_with\_source\_files)

- _source\_exts_(source\_files\_extensions)

- _build\_dir_(directory\_for\_object\_files\_and\_for\_program)
 
- _include_dirs_(list\_of\_directories\_for\_header\_files)

- _makefile\_name_(name\_for\_Makefile)

- _libraries_(list\_of\_linked\_libraries)

- _library\_dirs_(directory\_lst\_to\_search\_libraries)

Command _project_ specifies the project name and the name of the main file (i.e. the name of the file containing function 'main'). The name of the main file is optional. The default name of the main file is the project name with prepended
extension cpp. If command _project_ is not specified, then the name of the main file is 'main.cpp' and the project name is 'main'.  
Команда compiler задаёт имя используемого компилятора. 
По умолчанию (если эта команда не задана) используется компилятор g++.  
Команда compiler\_flags определяет флаги, передаваемые компилятором. Флаги по умолчанию: -O3 -Wall -std=c++14.  
Команда linker определяет имя компановщика. По умолчанию это - имя компилятора.  
Команда linker\_flags определяет флаги компановщика. Флаги по умолчанию: -s.  
Команда source\_dir определяет каталог с исходными текстами (имеется в виду файлы с расширениями cpp, c++, cxx).  По умолчанию это - текущий каталог.  
Команда source\_exts задаёт расширение файлов с исходным текстом (расширение заголовочных файлов сюда включать не нужно).  
Команда build\_dir определяет каталог, в котором будут находиться объектные файлы и исполняемый файл. Если эта команда не задана, то они будут находиться в корневом каталоге проекта.  
Команда include\_dirs определяет где находится заголовочные файлы для внешних библиотек.  
Команда makefile\_name задаёт имя генерируемого Makefile'а. По умолчанию используется имя Makefile.

Команда libraries определяет заключённый в кавычки список имён подключаемых библиотек, разделённых пробельными символами. Формат имени таков: не нужно указывать префикс lib и суффикс .a.

Команда library\_dirs определяет список путей поиска для подключаемых библиотек.
 
 Здесь project\_name, name\_for\_Makefile, compiler\_name, linker\_name - идентификаторы. Все прочие аргументы вышеуказанных команд являются строковыми литералами. Под идентификатором понимается любая непустая последовательность латинских букв, десятичных цифр, знаков '+' и '-', знака подчёркивания и точки. Под строковым литералом понимается любая (в том числе и пустая) последовательность символов, заключённая в двойные кавычки. При этом если в строковом литерале нужно указать двойную кавычку, то её следует удвоить.   
 Строковый литерал, являющийся значением аргумента команды source\_exts, представляет из себя список расширений файлов с исходным текстом, разделённых пробельными символами, т.е. пробелами и табуляциями. Расширения нужно указывать без ведущей точки.
 
 Аргумент команды include\_dirs содержит в себе список разделённых точками с запятыми путей к каталогам, содержащим заголовочные файлы для внешних библиотек.
 
 Аргумент команды library\_dirs содержит в себе список разделённых точками с запятыми путей к каталогам, содержащим подключаемые внешние библиотеки.
 
# Примеры
 
 Приведём примеры использования программы Мурлыка.
 
## Пример 1.  
 Пусть дан проект simple01, имеющий следующую структуру:  

	simple01  
		func1.cpp  
		func1.h  
		func2.cpp  
		func2.h  
		simple01.cpp  
		build
     
Допустим, что головным файлом является simple01.cpp, а каталогом сборки - каталог build. Если в корневой каталог проекта поместить файл с именем, например, mkdescr.txt (имя может быть и любым другим, с любым другим расширением) с содержимым

>project(simple01)  
>compiler(g++)  
>linker(g++)  
>source_exts("cpp")  
>build_dir("build")  

то при подаче Мурлыке на вход этого файла получим Makefile со следующим содержимым:

	LINKER      = g++  
	LINKERFLAGS = -s  
	CXX         = g++  
	CXXFLAGS    = -O3 -Wall -std=c++14  
	BIN         = simple01  
	vpath %.o build  
	OBJ         = simple01.o func2.o func1.o  
	LINKOBJ     = simple01.o func2.o func1.o  

	.PHONY: all all-before all-after clean clean-custom

	all: all-before $(BIN) all-after

	clean: clean-custom   
		rm -f ./build/*.o  
		rm -f ./build/$(BIN)

	.cpp.o:  
		$(CXX) -c $< -o $@ $(CXXFLAGS) 

	$(BIN):$(OBJ)  
		$(LINKER) -o $(BIN) $(LINKOBJ) $(LINKERFLAGS)  
		mv $(BIN) $(OBJ) ./build

## Пример 2.  
Пусть имеется проект simple02 со следующей структурой:  

	simple02  
		build  
		include  
			func1.h  
			func2.h  
		src  
			func1.cpp  
			func2.cpp  
			simple02.cpp

Иными словами, файлы с расширением h находятся в каталоге include, а файлы с расширением cpp - в каталоге src.   
Допустим, что головным файлом является simple02.cpp, а каталогом сборки - каталог build. Если в корневой каталог проекта поместить файл с именем, например, mkdescr.txt (имя может быть и любым другим, с любым другим расширением) с содержимым

>project(simple02)  
>compiler(g++)  
>linker(g++)  
>source_exts("cpp")  
>source_dir("src")  
>build_dir("build")  

то при подаче Мурлыке на вход этого файла получим Makefile со следующим содержимым:  

	LINKER           = g++  
	LINKERFLAGS      = -s  
	COMPILER         = g++  
	COMPILERFLAGS    = -O3 -Wall -std=c++14  
	BIN              = simple02  
	vpath %.cpp src  
	vpath %.o build  
	OBJ              = simple02.o func2.o func1.o  
	LINKOBJ          = build/simple02.o build/func2.o build/func1.o  

	.PHONY: all all-before all-after clean clean-custom

	all: all-before $(BIN) all-after

	clean: clean-custom  
		rm -f ./build/*.o  
		rm -f ./build/$(BIN)  

	.cpp.o:  
		$(CXX) -c $< -o $@ $(CXXFLAGS)   
		mv $@ ./build

	$(BIN):$(OBJ)  
		$(LINKER) -o $(BIN) $(LINKOBJ) $(LINKERFLAGS)  
		mv $(BIN) ./build

# Как собрать данный проект
Для сборки данного проекта нужна Haskell Platform. 
При этом для сборки нужно перейти в корневой каталог данного проекта, и выполнить

```bash
$ cabal configure
$ cabal build
```
